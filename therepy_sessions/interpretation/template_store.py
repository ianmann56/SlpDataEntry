from interpretation.template_manager.student_data_sheet_template import StudentDataSheetTemplate


class TemplateCreateDto:
    """
    Data Transfer Object for creating new templates.
    
    Does not include ID as it will be generated by the store.
    """
    
    def __init__(self, name, file_location, configured_interpreter):
        """
        Initialize the create DTO.
        
        Args:
            name (str): The name of the template
            file_location (str): The file location of the template
            configured_interpreter: The configured interpreter object
        """
        self.name = name
        self.file_location = file_location
        self.configured_interpreter = configured_interpreter


class TemplateEditDto:
    """
    Data Transfer Object for editing existing templates.
    
    Does not include ID as it should remain unchanged during edits.
    """
    
    def __init__(self, name, file_location, configured_interpreter):
        """
        Initialize the edit DTO.
        
        Args:
            name (str): The name of the template
            file_location (str): The file location of the template
            configured_interpreter: The configured interpreter object
        """
        self.name = name
        self.file_location = file_location
        self.configured_interpreter = configured_interpreter


class TemplateStore:
    """
    Repository for managing Student Data Sheet Templates.

    This is a stub implementation that keeps templates in RAM.
    In a real implementation, this would handle persistence to files,
    databases, or other storage mechanisms.
    """

    def __init__(self):
        """Initialize the template store with sample data."""
        self._templates = [
            # StudentDataSheetTemplate("1", "Running Tally Template", "/path/to/template1"),
            # StudentDataSheetTemplate("2", "Table Template", "/path/to/template2"),
            # StudentDataSheetTemplate("3", "Mixed Data Template", "/path/to/template3")
        ]

    def get_all_templates(self):
        """
        Retrieve all available templates.

        Returns:
            list: List of StudentDataSheetTemplate objects
        """
        return self._templates.copy()

    def get_template_by_id(self, template_id):
        """
        Retrieve a template by its ID.

        Args:
            template_id (str): The ID of the template to retrieve

        Returns:
            StudentDataSheetTemplate or None: The template if found, None otherwise
        """
        for template in self._templates:
            if template.id == template_id:
                return template
        return None

    def create_template(self, create_dto):
        """
        Create a new template from a DTO.

        Args:
            create_dto (TemplateCreateDto): The data for the new template

        Returns:
            StudentDataSheetTemplate: The created template with generated ID
        """
        # Generate a new unique ID
        new_id = self.generate_new_id()
        
        # Create the template object
        new_template = StudentDataSheetTemplate(
            new_id,
            create_dto.name,
            create_dto.file_location,
            create_dto.configured_interpreter
        )
        
        # Add to the templates list
        self._templates.append(new_template)
        
        return new_template
        
    def edit_template(self, template_id, edit_dto):
        """
        Edit an existing template using a DTO.

        Args:
            template_id (str): The ID of the template to edit
            edit_dto (TemplateEditDto): The new data for the template

        Returns:
            StudentDataSheetTemplate or None: The updated template if found, None if not found
        """
        # Find the template to edit
        for i, template in enumerate(self._templates):
            if template.id == template_id:
                # Create updated template with same ID
                updated_template = StudentDataSheetTemplate(
                    template_id,  # Keep the same ID
                    edit_dto.name,
                    edit_dto.file_location,
                    edit_dto.configured_interpreter
                )
                
                # Replace the template in the list
                self._templates[i] = updated_template
                # With the real implementation, don't forget to delete the old file if changing file_location.
                
                return updated_template
                
        # Template not found
        return None

    def delete_template(self, template_id):
        """
        Delete a template by its ID.

        Args:
            template_id (str): The ID of the template to delete

        Returns:
            bool: True if template was found and deleted, False otherwise
        """
        for i, template in enumerate(self._templates):
            if template.id == template_id:
                del self._templates[i]
                return True
        return False

    def generate_new_id(self):
        """
        Generate a new unique ID for a template.

        Returns:
            str: A new unique ID
        """
        # Simple implementation - find the highest numeric ID and add 1
        max_id = 0
        for template in self._templates:
            try:
                template_id_num = int(template.id)
                if template_id_num > max_id:
                    max_id = template_id_num
            except ValueError:
                # Non-numeric ID, skip
                pass
        return str(max_id + 1)